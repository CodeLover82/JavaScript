< let >
: let으로 선언한 변수는 블록을 벗어나면 사용할 수 없다.

< const > 
: const로 선언한 변수는 상수값을 선언할 때 사용.

< + 연산자 >
: 두 수를 더할 때에도 + 기호를 사용하지만, 두 개 이상의 문자열을 연결할 때도 + 기호를 사용하며, 이 때는 연결 연산자라고 부른다.

< 연결 연산자 >
: 숫자로 된 문자열과 숫자를 +로 이으면 연결연산자로 작용하고, 나머지 -, *, /, %로 이으면 산술 연산자로 작용한다.
ex) 100 + ‘50’ = ‘10050’, 100 - ‘50’ = 50

< 템플릿 문자열 >
: 문자열과 값 그리고 다시 문자열을 연결하는 방식이 아니라, 문자열 안에 값을 끼워 넣는 방식.
템플릿 문자열을 사용할 때는 문자열을 백쿼트(`)로 묶고, 값이 들어가는 부분은 ${} 사이에 표시한다.

< == vs === >
: ==은 문자형 자료와 숫자형 자료가 있을 때, 자동으로 자료형을 변환하여 비교하지만, ===은 두 자료형의 변환을 허용하지 않기 때문에 자료형이 완벽히 일치해야 한다.

indow 객체 >
: 모든 객체를 품고 있는 최상위 객체이기 때문에 window 객체의 메서드를 실행할 때는 함수 이름만 사용해도 된다. (. 없이)


 이벤트 발생 요소 가리키기 >
: 이벤트 핸들러 함수에서 this 키워드는 이벤트 핸들러가 등록된 DOM 요소를 가리킨다.




< this 객체 >
: this는 기본적으로 window 객체를 가리킨다. 그러나 객체 메서드 안의 this는 해당 객체를 가리킨다. 이것은 객체의 메서드를 호출할 때 this를 내부적으로 바꿔주기 때문이다. 따라서 호출할 때, 호출하는 함수가 객체의 메서드인지 그냥 함수인지가 중요하며 this가 무엇을 가리키는지 결정하는 요소이다.
이벤트가 발생했을 때는, 이벤트 핸들러 내에서 내부적으로 this가 해당 요소로 바뀌기 때문에 외워야 한다.
ex) function a() { console.log(this); };  a(); // Window {}
    var obj = { a: function() { console.log(this); } };  obj.a(); // obj    var a2 = obj.a;  a2(); // window
    $('div').on('click', function() {
  	console.log(this); // <div>
  	function inner() {
    	   console.log(this); //  Window    => 함수의 this는 기본적으로 window라는 원칙을 충실히 따른 것이다.
  	}
    	inner();
    });
   => 위의 문제를 해결하기 위해서는 
   $('div').on('click', function() {
  	console.log(this); // <div>
        var that = this;
  	function inner() {
    	   console.log(that); // <div>
  	}
    	inner();
    }); 
    처럼 해야 한다.
